import { MINI_SIZE, MS_PER_PIXEL } from "consts";
import { State } from "initCreator";
import Texture from "models/Texture";
import MiniatureVideo from "models/Video/MiniatureVideo";
import { drawShape, drawSprite } from "programs";
import { canvasMatrix } from "programs/canvasMatrix";
import { setAttribute, setIndex } from "programs/utils/setAttribute";
import renderSprite from "renders/renderSprite";
import setupRenderTarget from "renders/setupRenderTarget";
import { skeletonSize, updateTimelineWidth } from "UI";
import m3 from "utils/m3";

// we should also try keep constant attributes in one buffer
// const vao = drawSprite.createVAO(
//   texCoords,
//   positions,
//   new Float32Array([0, 0, 0, 0]),
//   indexes
// );

/*
function renderTexture(index: number, startX: number, video: MiniatureVideo) {
  const x = startX + index * MINI_SIZE;
  const textureUnit = 0;
  const gl = window.gl;
  gl.activeTexture(gl.TEXTURE0 + textureUnit); // activate certain texture unit
  gl.bindTexture(gl.TEXTURE_2D_ARRAY, video.textureAtlas);

  drawSprite.setup(
    vao,
    textureUnit,
    m3.translate(canvasMatrix, x, skeletonSize.timeline.y)
  );
  setupRenderTarget(null);
  renderSprite();
}
*/

// tslint:disable: no-console
const vertexShaderSrc = `#version 300 es
layout(location=0) in vec2 aPosition;
layout(location=1) in vec4 aColor;
layout(location=2) in float aOffset;

out vec4 vColor;

void main()
{
    vColor = aColor;
    gl_Position = vec4(aPosition + aOffset, 0, 1);
}`;

const fragmentShaderSrc = `#version 300 es
precision mediump float;
in vec4 vColor;
out vec4 fragColor;

void main()
{
    fragColor = vColor;
}`;
const gl = window.gl;

const program = gl.createProgram();
if (!program) throw Error("0");

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
if (!vertexShader) throw Error("1");
gl.shaderSource(vertexShader, vertexShaderSrc);
gl.compileShader(vertexShader);
gl.attachShader(program, vertexShader);
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
if (!fragmentShader) throw Error("2");
gl.shaderSource(fragmentShader, fragmentShaderSrc);
gl.compileShader(fragmentShader);
gl.attachShader(program, fragmentShader);

gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.log(gl.getShaderInfoLog(vertexShader));
  console.log(gl.getShaderInfoLog(fragmentShader));
}
gl.useProgram(program);

// const modelData = new Float32Array([
// position    texCoord
// -1, -0.7, 0, 1, 0, 0.8, 0.5, 0, 1, -0.7, 1, 1,
// ]);
// const transformData = new Float32Array([
//   // offset     scale    color       depth
//   -0.2, 0.7, 0.7, 1, 0, 0, 1, 0.3, -0.5, 0.4, 0, 0, 1, 0,
// ]);
const modelData = new Float32Array([0, 0.5, 0.3, -0.2, -0.3, -0.2]);
// const modelData = new Float32Array([
//   0, 0, 0, 0.5, 0.5, 0.5, 0, 0, 0, -0.5, -0.5, -0.5,
// ]);
const transformData = new Float32Array([
  1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1,
]);
const offsetData = new Float32Array([0.1, -0.5, 0.7, -1]);

const main = async () => {
  const modelBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 4 * 2, 0);
  gl.vertexAttribDivisor(0, 0); // 0 means to reuse for all, so it's like lack of calling vertexAttribDivisor
  gl.enableVertexAttribArray(0);

  const transformBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, transformBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, transformData, gl.STATIC_DRAW);

  gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 4 * 4, 0);
  // gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 28, 8);

  gl.vertexAttribDivisor(1, 0); //this one doesn't work with 0?! Buffer is not big enough??
  // so
  // 0 - attribute is pulled base on verticle index(so all instances have same attributes)
  // 1 - attribute is pulled base on instance index(so each instance has different attribute, but each verticle has same)
  // 2 - same as 1, but index is divided by 2, so first two has same attribute(where index = 0), third has the attribute under index = 1
  // gl.vertexAttribDivisor(2, 1);

  gl.enableVertexAttribArray(1);
  // gl.enableVertexAttribArray(2);

  const offsetBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, offsetData, gl.STATIC_DRAW);

  gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 4, 0);
  // gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 28, 8);

  gl.vertexAttribDivisor(2, 1); //this one doesn't work with 0?! Buffer is not big enough??
  // gl.vertexAttribDivisor(2, 1);

  gl.enableVertexAttribArray(2);

  gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 3);
};

export function getMiniatureTexCoords(width: number, height: number) {
  const offsetY = (Math.max(0, height - width) * 0.5) / height;
  const offsetX = (Math.max(0, width - height) * 0.5) / width;

  return new Float32Array([
    offsetX,
    offsetY,
    offsetX,
    1 - offsetY,
    1 - offsetX,
    1 - offsetY,
    1 - offsetX,
    offsetY,
  ]);
}

function getStartX(currTime: number) {
  const skeleton = skeletonSize.timeline;
  const offset =
    skeleton.x + // skeleton.x is 0 so nto sure if we really need that
    skeleton.width / 2 -
    currTime / MS_PER_PIXEL;

  return offset < 0 ? offset % MINI_SIZE : offset;
}

function getStartTime(currTime: number) {
  const timeOffset =
    currTime - skeletonSize.timeline.width * 0.5 * MS_PER_PIXEL;
  const safeTimeOffset = Math.max(0, timeOffset); // we don't need a time shift until first miniatures hides

  return Math.floor(safeTimeOffset / MS_PER_MINI) * MS_PER_MINI;
}

function getMiniaturesNumber(startTime: number, video: MiniatureVideo) {
  const length = (video.duration - startTime) / MS_PER_PIXEL;
  // the distance from first miniature to the last that we are planning to render
  return Math.ceil(length / MINI_SIZE);
}

let avgValue = 0;
let avgNumber = 0;

export default class Timeline {
  // private video: MiniatureVideo;

  constructor(videoUrl: string, state: State) {
    // this.video = new MiniatureVideo(
    //   videoUrl,
    //   (duration) => {
    //     const width = duration / MS_PER_PIXEL;
    //     updateTimelineWidth(width);
    //     state.refresh();
    //   },
    //   () => state.currTime
    // );
  }

  render(state: State) {
    main();
    return;
    // TODO: those miniatures still look like are stretched vertically too much

    const _positions = new Float32Array([
      0, 0, 0, 0.5, 0.5, 0.5, 0, 0, 0, -0.5, -0.5, -0.5,
    ]);

    /*
    const texCoords = new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]);
    const positions = new Float32Array([
      0,
      0,
      0,
      MINI_SIZE,
      MINI_SIZE,
      MINI_SIZE,
      MINI_SIZE,
      0,
    ]);
    const depth = new Float32Array([0, 0, 0, 0]);
    const indexes = new Uint16Array([0, 1, 2, 0, 2, 3]);
*/
    // setAttribute(0, _positions, 0);
    console.log("-----");
    drawShape.setup();

    const arrayBufferLocation = gl.createBuffer();
    if (!arrayBufferLocation) throw Error("gl.createBuffer");

    gl.bindBuffer(gl.ARRAY_BUFFER, arrayBufferLocation); // seems like I
    gl.bufferData(gl.ARRAY_BUFFER, _positions, gl.STATIC_DRAW);

    // gl.vertexAttrib3f What is that?
    gl.vertexAttribPointer(
      0,
      2, // size, components per iteration
      gl.FLOAT, // type, the data is 32bit floats
      false, // normalize, don't normalize the data. Only applies to integers(8 and 16-bit), so effect on floats. So if it's unsigned i8, value will be normalized assuming that max is 255, min is 0
      2 * 4, // stride, 0 = move forward size * sizeof(type) each iteration to get the next position
      // stride is the length of each chunk, measure in bytes, one 32Float is 4 bytes
      //  attrib.stride = stride ? stride : sizeof(type) * size;
      0 // offset, start at the beginning of the buffer
      // number of bytes we need to skip to get first value
    );

    // gl.vertexAttribDivisor(0, 0); // For 1 it doesn't work....

    gl.enableVertexAttribArray(0);

    // setAttribute(0, _positions, 2 * 4);

    // gl.vertexAttribDivisor(0, 100); // position
    // gl.vertexAttribDivisor(1, 100); // texture
    // gl.vertexAttribDivisor(2, 100); // depth

    // setupRenderTarget(null);

    // gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 3);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    //     return;
    //     if (!this.video.isReady) return;
    //     const start = performance.now();
    //     const startX = getStartX(state.currTime);
    //     const startTime = getStartTime(state.currTime);
    //     const length = getMiniaturesNumber(startTime, this.video);
    //     /* setup 3x texture */
    //     const textureUnit = 0;
    //     gl.activeTexture(gl.TEXTURE0 + textureUnit); // activate certain texture unit
    //     gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.video.textureAtlas);

    //     /* collect all attributes for instance drawing */
    //     for (let i = 0; i < length; i++) {
    //       const time = startTime + i * MS_PER_MINIATURE;
    //       this.video.getMiniature(time, () => state.refresh()); // DO NOT pass state.refresh as a param. "this" will be messed up inside refresh function
    //       // renderTexture(i, startX, this.video);
    //       // const time = currTime + i * MS_PER_MINIATURE // THIS IS CORRECT
    //     }

    //     const attrs = {
    //       a_position: 0,
    //       a_texCoord: 1,
    //       aDepth: 2,
    //     } as const;

    //     // gl.vertexAttribDivisor(0, 10); // position
    //     // gl.vertexAttribDivisor(1, 10); // texture
    //     // gl.vertexAttribDivisor(2, 10); // depth
    //     const texCoords = new Float32Array([0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0]);
    //     const positions = new Float32Array([
    //       0,
    //       0,
    //       0,
    //       MINI_SIZE,
    //       MINI_SIZE,
    //       MINI_SIZE,
    //       MINI_SIZE,
    //       0,
    //       MINI_SIZE,
    //       MINI_SIZE,
    //       0,
    //       0,
    //     ]);
    //     const depth = new Float32Array([0, 0, 0, 0, 0, 0]);

    //     /*
    //     const texCoords = new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]);
    //     const positions = new Float32Array([
    //       0,
    //       0,
    //       0,
    //       MINI_SIZE,
    //       MINI_SIZE,
    //       MINI_SIZE,
    //       MINI_SIZE,
    //       0,
    //     ]);
    //     const depth = new Float32Array([0, 0, 0, 0]);
    //     const indexes = new Uint16Array([0, 1, 2, 0, 2, 3]);
    // */
    //     setAttribute(attrs.a_position, positions, 2 * 4);
    //     setAttribute(attrs.a_texCoord, texCoords, 2 * 4);
    //     setAttribute(attrs.aDepth, depth, 1 * 4, 1);
    //     // if you will need to edit attributes, just bind the buffer and update the data!
    //     // setIndex(indexes);

    //     drawSprite.setup(
    //       // vao,
    //       textureUnit,
    //       m3.translate(canvasMatrix, startX, skeletonSize.timeline.y)
    //     );

    //     // gl.vertexAttribDivisor(0, 100); // position
    //     // gl.vertexAttribDivisor(1, 100); // texture
    //     // gl.vertexAttribDivisor(2, 100); // depth

    //     setupRenderTarget(null);

    //     gl.drawArrays(gl.TRIANGLES, 0, 6);
    //     // gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    //     // gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0, 2); // wh ythe f*** first drawing is 6?!

    //     const end = performance.now();
    //     avgValue += end - start;
    //     avgNumber++;

    //     if (avgNumber % 60 === 0) {
    //       console.log("avg", avgValue / avgNumber);
    //     }

    //     gl.enable(gl.SCISSOR_TEST);
    //     gl.scissor(
    //       startX +
    //         (length - 1) * MINI_SIZE +
    //         (((this.video.duration - startTime) / MS_PER_PIXEL) % MINI_SIZE),
    //       gl.drawingBufferHeight -
    //         skeletonSize.timeline.y -
    //         skeletonSize.timeline.height,
    //       MINI_SIZE,
    //       MINI_SIZE
    //     );
    //     gl.clearColor(0, 0, 0, 1.0);
    //     gl.clear(gl.COLOR_BUFFER_BIT);
    //     gl.disable(gl.SCISSOR_TEST);
  }
}
